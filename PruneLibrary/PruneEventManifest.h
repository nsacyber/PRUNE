//**********************************************************************`
//* This is an include file generated by Message Compiler.             *`
//*                                                                    *`
//* Copyright (c) Microsoft Corporation. All Rights Reserved.          *`
//**********************************************************************`
#pragma once

//*****************************************************************************
//
// Notes on the ETW event code generated by MC:
//
// - Structures and arrays of structures are treated as an opaque binary blob.
//   The caller is responsible for packing the data for the structure into a
//   single region of memory, with no padding between values. The macro will
//   have an extra parameter for the length of the blob.
// - Arrays of nul-terminated strings must be packed by the caller into a
//   single binary blob containing the correct number of strings, with a nul
//   after each string. The size of the blob is specified in characters, and
//   includes the final nul.
// - If a SID is provided, its length will be determined by calling
//   GetLengthSid.
// - Arrays of SID are treated as a single binary blob. The caller is
//   responsible for packing the SID values into a single region of memory with
//   no padding.
// - The length attribute on the data element in the manifest is significant
//   for values with intype win:UnicodeString, win:AnsiString, or win:Binary.
//   The length attribute must be specified for win:Binary, and is optional for
//   win:UnicodeString and win:AnsiString (if no length is given, the strings
//   are assumed to be nul-terminated). For win:UnicodeString, the length is
//   measured in characters, not bytes.
// - For an array of win:UnicodeString, win:AnsiString, or win:Binary, the
//   length attribute applies to every value in the array, so every value in
//   the array must have the same length. The values in the array are provided
//   to the macro via a single pointer -- the caller is responsible for packing
//   all of the values into a single region of memory with no padding between
//   values.
// - Values of type win:CountedUnicodeString, win:CountedAnsiString, and
//   win:CountedBinary can be generated and collected on Vista or later.
//   However, they may not decode properly without the Windows 10 2018 Fall
//   Update.
// - Arrays of type win:CountedUnicodeString, win:CountedAnsiString, and
//   win:CountedBinary must be packed by the caller into a single region of
//   memory. The format for each item is a UINT16 byte-count followed by that
//   many bytes of data. When providing the array to the generated macro, you
//   must provide the total size of the packed array data, including the UINT16
//   sizes for each item. In the case of win:CountedUnicodeString, the data
//   size is specified in WCHAR (16-bit) units. In the case of
//   win:CountedAnsiString and win:CountedBinary, the data size is specified in
//   bytes.
//
//*****************************************************************************

#include <wmistr.h>
#include <evntrace.h>
#include <evntprov.h>

#if !defined(ETW_INLINE)
#define ETW_INLINE DECLSPEC_NOINLINE __inline
#endif

#if defined(__cplusplus)
extern "C" {
#endif

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// MCGEN_USE_KERNEL_MODE_APIS macro:
// Controls whether the generated code uses kernel-mode or user-mode APIs.
// - Set to 0 to use Windows user-mode APIs such as EventRegister.
// - Set to 1 to use Windows kernel-mode APIs such as EtwRegister.
// Default is based on whether the _ETW_KM_ macro is defined (i.e. by wdm.h).
// Note that the APIs can also be overridden directly, e.g. by setting the
// MCGEN_EVENTWRITETRANSFER or MCGEN_EVENTREGISTER macros.
//
#ifndef MCGEN_USE_KERNEL_MODE_APIS
  #ifdef _ETW_KM_
    #define MCGEN_USE_KERNEL_MODE_APIS 1
  #else
    #define MCGEN_USE_KERNEL_MODE_APIS 0
  #endif
#endif // MCGEN_USE_KERNEL_MODE_APIS

//
// MCGEN_HAVE_EVENTSETINFORMATION macro:
// Controls how McGenEventSetInformation uses the EventSetInformation API.
// - Set to 0 to disable the use of EventSetInformation
//   (McGenEventSetInformation will always return an error).
// - Set to 1 to directly invoke MCGEN_EVENTSETINFORMATION.
// - Set to 2 to to locate EventSetInformation at runtime via GetProcAddress
//   (user-mode) or MmGetSystemRoutineAddress (kernel-mode).
// Default is determined as follows:
// - If MCGEN_EVENTSETINFORMATION has been customized, set to 1
//   (i.e. use MCGEN_EVENTSETINFORMATION).
// - Else if the target OS version has EventSetInformation, set to 1
//   (i.e. use MCGEN_EVENTSETINFORMATION).
// - Else set to 2 (i.e. try to dynamically locate EventSetInformation).
// Note that an McGenEventSetInformation function will only be generated if one
// or more provider in a manifest has provider traits.
//
#ifndef MCGEN_HAVE_EVENTSETINFORMATION
  #ifdef MCGEN_EVENTSETINFORMATION             // if MCGEN_EVENTSETINFORMATION has been customized,
    #define MCGEN_HAVE_EVENTSETINFORMATION   1 //   directly invoke MCGEN_EVENTSETINFORMATION(...).
  #elif MCGEN_USE_KERNEL_MODE_APIS             // else if using kernel-mode APIs,
    #if NTDDI_VERSION >= 0x06040000            //   if target OS is Windows 10 or later,
      #define MCGEN_HAVE_EVENTSETINFORMATION 1 //     directly invoke MCGEN_EVENTSETINFORMATION(...).
    #else                                      //   else
      #define MCGEN_HAVE_EVENTSETINFORMATION 2 //     find "EtwSetInformation" via MmGetSystemRoutineAddress.
    #endif                                     // else (using user-mode APIs)
  #else                                        //   if target OS and SDK is Windows 8 or later,
    #if WINVER >= 0x0602 && defined(EVENT_FILTER_TYPE_SCHEMATIZED)
      #define MCGEN_HAVE_EVENTSETINFORMATION 1 //     directly invoke MCGEN_EVENTSETINFORMATION(...).
    #else                                      //   else
      #define MCGEN_HAVE_EVENTSETINFORMATION 2 //     find "EventSetInformation" via GetModuleHandleExW/GetProcAddress.
    #endif
  #endif
#endif // MCGEN_HAVE_EVENTSETINFORMATION

//
// MCGEN_EVENTWRITETRANSFER macro:
// Override to use a custom API.
//
#ifndef MCGEN_EVENTWRITETRANSFER
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define MCGEN_EVENTWRITETRANSFER   EtwWriteTransfer
  #else
    #define MCGEN_EVENTWRITETRANSFER   EventWriteTransfer
  #endif
#endif // MCGEN_EVENTWRITETRANSFER

//
// MCGEN_EVENTREGISTER macro:
// Override to use a custom API.
//
#ifndef MCGEN_EVENTREGISTER
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define MCGEN_EVENTREGISTER        EtwRegister
  #else
    #define MCGEN_EVENTREGISTER        EventRegister
  #endif
#endif // MCGEN_EVENTREGISTER

//
// MCGEN_EVENTSETINFORMATION macro:
// Override to use a custom API.
// (McGenEventSetInformation also affected by MCGEN_HAVE_EVENTSETINFORMATION.)
//
#ifndef MCGEN_EVENTSETINFORMATION
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define MCGEN_EVENTSETINFORMATION  EtwSetInformation
  #else
    #define MCGEN_EVENTSETINFORMATION  EventSetInformation
  #endif
#endif // MCGEN_EVENTSETINFORMATION

//
// MCGEN_EVENTUNREGISTER macro:
// Override to use a custom API.
//
#ifndef MCGEN_EVENTUNREGISTER
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define MCGEN_EVENTUNREGISTER      EtwUnregister
  #else
    #define MCGEN_EVENTUNREGISTER      EventUnregister
  #endif
#endif // MCGEN_EVENTUNREGISTER

//
// MCGEN_PENABLECALLBACK macro:
// Override to use a custom function pointer type.
// (Should match the type used by MCGEN_EVENTREGISTER.)
//
#ifndef MCGEN_PENABLECALLBACK
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define MCGEN_PENABLECALLBACK      PETWENABLECALLBACK
  #else
    #define MCGEN_PENABLECALLBACK      PENABLECALLBACK
  #endif
#endif // MCGEN_PENABLECALLBACK

//
// MCGEN_GETLENGTHSID macro:
// Override to use a custom API.
//
#ifndef MCGEN_GETLENGTHSID
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define MCGEN_GETLENGTHSID(p)      RtlLengthSid((PSID)(p))
  #else
    #define MCGEN_GETLENGTHSID(p)      GetLengthSid((PSID)(p))
  #endif
#endif // MCGEN_GETLENGTHSID

//
// MCGEN_EVENT_ENABLED macro:
// Controls how the EventWrite[EventName] macros determine whether an event is
// enabled. The default behavior is for EventWrite[EventName] to use the
// EventEnabled[EventName] macros.
//
#ifndef MCGEN_EVENT_ENABLED
#define MCGEN_EVENT_ENABLED(EventName) EventEnabled##EventName()
#endif

//
// MCGEN_EVENT_BIT_SET macro:
// Implements testing a bit in an array of ULONG, optimized for CPU type.
//
#ifndef MCGEN_EVENT_BIT_SET
#  if defined(_M_IX86) || defined(_M_X64)
#    define MCGEN_EVENT_BIT_SET(EnableBits, BitPosition) ((((const unsigned char*)EnableBits)[BitPosition >> 3] & (1u << (BitPosition & 7))) != 0)
#  else
#    define MCGEN_EVENT_BIT_SET(EnableBits, BitPosition) ((EnableBits[BitPosition >> 5] & (1u << (BitPosition & 31))) != 0)
#  endif
#endif // MCGEN_EVENT_BIT_SET

//
// MCGEN_ENABLE_CHECK macro:
// Determines whether the specified event would be considered as enabled
// based on the state of the specified context. Slightly faster than calling
// McGenEventEnabled directly.
//
#ifndef MCGEN_ENABLE_CHECK
#define MCGEN_ENABLE_CHECK(Context, Descriptor) (Context.IsEnabled && McGenEventEnabled(&Context, &Descriptor))
#endif

#if !defined(MCGEN_TRACE_CONTEXT_DEF)
#define MCGEN_TRACE_CONTEXT_DEF
typedef struct _MCGEN_TRACE_CONTEXT
{
    TRACEHANDLE            RegistrationHandle;
    TRACEHANDLE            Logger;      // Used as pointer to provider traits.
    ULONGLONG              MatchAnyKeyword;
    ULONGLONG              MatchAllKeyword;
    ULONG                  Flags;
    ULONG                  IsEnabled;
    UCHAR                  Level;
    UCHAR                  Reserve;
    USHORT                 EnableBitsCount;
    PULONG                 EnableBitMask;
    const ULONGLONG*       EnableKeyWords;
    const UCHAR*           EnableLevel;
} MCGEN_TRACE_CONTEXT, *PMCGEN_TRACE_CONTEXT;
#endif // MCGEN_TRACE_CONTEXT_DEF

#if !defined(MCGEN_LEVEL_KEYWORD_ENABLED_DEF)
#define MCGEN_LEVEL_KEYWORD_ENABLED_DEF
//
// Determines whether an event with a given Level and Keyword would be
// considered as enabled based on the state of the specified context.
// Note that you may want to use MCGEN_ENABLE_CHECK instead of calling this
// function directly.
//
FORCEINLINE
BOOLEAN
McGenLevelKeywordEnabled(
    _In_ PMCGEN_TRACE_CONTEXT EnableInfo,
    _In_ UCHAR Level,
    _In_ ULONGLONG Keyword
    )
{
    //
    // Check if the event Level is lower than the level at which
    // the channel is enabled.
    // If the event Level is 0 or the channel is enabled at level 0,
    // all levels are enabled.
    //

    if ((Level <= EnableInfo->Level) || // This also covers the case of Level == 0.
        (EnableInfo->Level == 0)) {

        //
        // Check if Keyword is enabled
        //

        if ((Keyword == (ULONGLONG)0) ||
            ((Keyword & EnableInfo->MatchAnyKeyword) &&
             ((Keyword & EnableInfo->MatchAllKeyword) == EnableInfo->MatchAllKeyword))) {
            return TRUE;
        }
    }

    return FALSE;
}
#endif // MCGEN_LEVEL_KEYWORD_ENABLED_DEF

#if !defined(MCGEN_EVENT_ENABLED_DEF)
#define MCGEN_EVENT_ENABLED_DEF
//
// Determines whether the specified event would be considered as enabled based
// on the state of the specified context. Note that you may want to use
// MCGEN_ENABLE_CHECK instead of calling this function directly.
//
FORCEINLINE
BOOLEAN
McGenEventEnabled(
    _In_ PMCGEN_TRACE_CONTEXT EnableInfo,
    _In_ PCEVENT_DESCRIPTOR EventDescriptor
    )
{
    return McGenLevelKeywordEnabled(EnableInfo, EventDescriptor->Level, EventDescriptor->Keyword);
}
#endif // MCGEN_EVENT_ENABLED_DEF

#if !defined(MCGEN_CONTROL_CALLBACK)
#define MCGEN_CONTROL_CALLBACK

DECLSPEC_NOINLINE __inline
VOID
__stdcall
McGenControlCallbackV2(
    _In_ LPCGUID SourceId,
    _In_ ULONG ControlCode,
    _In_ UCHAR Level,
    _In_ ULONGLONG MatchAnyKeyword,
    _In_ ULONGLONG MatchAllKeyword,
    _In_opt_ PEVENT_FILTER_DESCRIPTOR FilterData,
    _Inout_opt_ PVOID CallbackContext
    )
/*++

Routine Description:

    This is the notification callback for Windows Vista and later.

Arguments:

    SourceId - The GUID that identifies the session that enabled the provider.

    ControlCode - The parameter indicates whether the provider
                  is being enabled or disabled.

    Level - The level at which the event is enabled.

    MatchAnyKeyword - The bitmask of keywords that the provider uses to
                      determine the category of events that it writes.

    MatchAllKeyword - This bitmask additionally restricts the category
                      of events that the provider writes.

    FilterData - The provider-defined data.

    CallbackContext - The context of the callback that is defined when the provider
                      called EtwRegister to register itself.

Remarks:

    ETW calls this function to notify provider of enable/disable

--*/
{
    PMCGEN_TRACE_CONTEXT Ctx = (PMCGEN_TRACE_CONTEXT)CallbackContext;
    ULONG Ix;
#ifndef MCGEN_PRIVATE_ENABLE_CALLBACK_V2
    UNREFERENCED_PARAMETER(SourceId);
    UNREFERENCED_PARAMETER(FilterData);
#endif

    if (Ctx == NULL) {
        return;
    }

    switch (ControlCode) {

        case EVENT_CONTROL_CODE_ENABLE_PROVIDER:
            Ctx->Level = Level;
            Ctx->MatchAnyKeyword = MatchAnyKeyword;
            Ctx->MatchAllKeyword = MatchAllKeyword;
            Ctx->IsEnabled = EVENT_CONTROL_CODE_ENABLE_PROVIDER;

            for (Ix = 0; Ix < Ctx->EnableBitsCount; Ix += 1) {
                if (McGenLevelKeywordEnabled(Ctx, Ctx->EnableLevel[Ix], Ctx->EnableKeyWords[Ix]) != FALSE) {
                    Ctx->EnableBitMask[Ix >> 5] |= (1 << (Ix % 32));
                } else {
                    Ctx->EnableBitMask[Ix >> 5] &= ~(1 << (Ix % 32));
                }
            }
            break;

        case EVENT_CONTROL_CODE_DISABLE_PROVIDER:
            Ctx->IsEnabled = EVENT_CONTROL_CODE_DISABLE_PROVIDER;
            Ctx->Level = 0;
            Ctx->MatchAnyKeyword = 0;
            Ctx->MatchAllKeyword = 0;
            if (Ctx->EnableBitsCount > 0) {
                RtlZeroMemory(Ctx->EnableBitMask, (((Ctx->EnableBitsCount - 1) / 32) + 1) * sizeof(ULONG));
            }
            break;

        default:
            break;
    }

#ifdef MCGEN_PRIVATE_ENABLE_CALLBACK_V2
    //
    // Call user defined callback
    //
    MCGEN_PRIVATE_ENABLE_CALLBACK_V2(
        SourceId,
        ControlCode,
        Level,
        MatchAnyKeyword,
        MatchAllKeyword,
        FilterData,
        CallbackContext
        );
#endif // MCGEN_PRIVATE_ENABLE_CALLBACK_V2

    return;
}

#endif // MCGEN_CONTROL_CALLBACK

#ifndef McGenEventWrite_def
#define McGenEventWrite_def
DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventWrite(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ LPCGUID ActivityId,
    _In_range_(1, 128) ULONG EventDataCount,
    _Inout_updates_(EventDataCount) EVENT_DATA_DESCRIPTOR* EventData
    )
{
    const USHORT UNALIGNED* Traits;

    // Some customized MCGEN_EVENTWRITETRANSFER macros might ignore ActivityId.
    UNREFERENCED_PARAMETER(ActivityId);

    Traits = (const USHORT UNALIGNED*)(UINT_PTR)Context->Logger;

    if (Traits == NULL) {
        EventData[0].Ptr = 0;
        EventData[0].Size = 0;
        EventData[0].Reserved = 0;
    } else {
        EventData[0].Ptr = (ULONG_PTR)Traits;
        EventData[0].Size = *Traits;
        EventData[0].Reserved = 2; // EVENT_DATA_DESCRIPTOR_TYPE_PROVIDER_METADATA
    }

    return MCGEN_EVENTWRITETRANSFER(
        Context->RegistrationHandle,
        Descriptor,
        ActivityId,
        NULL,
        EventDataCount,
        EventData);
}
#endif // McGenEventWrite_def

#if !defined(McGenEventRegisterUnregister)
#define McGenEventRegisterUnregister

#pragma warning(push)
#pragma warning(disable:6103)
DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventRegister(
    _In_ LPCGUID ProviderId,
    _In_opt_ MCGEN_PENABLECALLBACK EnableCallback,
    _In_opt_ PVOID CallbackContext,
    _Inout_ PREGHANDLE RegHandle
    )
/*++

Routine Description:

    This function registers the provider with ETW.

Arguments:

    ProviderId - Provider ID to register with ETW.

    EnableCallback - Callback to be used.

    CallbackContext - Context for the callback.

    RegHandle - Pointer to registration handle.

Remarks:

    Should not be called if the provider is already registered (i.e. should not
    be called if *RegHandle != 0). Repeatedly registering a provider is a bug
    and may indicate a race condition. However, for compatibility with previous
    behavior, this function will return SUCCESS in this case.

--*/
{
    ULONG Error;

    if (*RegHandle != 0)
    {
        Error = 0; // ERROR_SUCCESS
    }
    else
    {
        Error = MCGEN_EVENTREGISTER(ProviderId, EnableCallback, CallbackContext, RegHandle);
    }

    return Error;
}
#pragma warning(pop)

DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventUnregister(_Inout_ PREGHANDLE RegHandle)
/*++

Routine Description:

    Unregister from ETW and set *RegHandle = 0.

Arguments:

    RegHandle - the pointer to the provider registration handle

Remarks:

    If provider has not been registered (i.e. if *RegHandle == 0),
    return SUCCESS. It is safe to call McGenEventUnregister even if the
    call to McGenEventRegister returned an error.

--*/
{
    ULONG Error;

    if(*RegHandle == 0)
    {
        Error = 0; // ERROR_SUCCESS
    }
    else
    {
        Error = MCGEN_EVENTUNREGISTER(*RegHandle);
        *RegHandle = (REGHANDLE)0;
    }

    return Error;
}

#endif // McGenEventRegisterUnregister

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Provider "Prune-Log" event count 12
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Provider GUID = 75aa90da-302b-40fe-8760-80ed0b90d9d6
EXTERN_C __declspec(selectany) const GUID PRUNE_EVENT_PROVIDER = {0x75aa90da, 0x302b, 0x40fe, {0x87, 0x60, 0x80, 0xed, 0x0b, 0x90, 0xd9, 0xd6}};

#ifndef PRUNE_EVENT_PROVIDER_Traits
#define PRUNE_EVENT_PROVIDER_Traits NULL
#endif // PRUNE_EVENT_PROVIDER_Traits

//
// Channel
//
#define PRUNE_EVENT_PROVIDER_CHANNEL_Prune_Log_Admin 0x14

//
// Opcodes
//
#define OPCODE_ERROR 0x1e
#define OPCODE_HOST_NAME_ERROR 0x15
#define OPCODE_FINISHED_MONITORING 0x16
#define OPCODE_CANNOT_GATHER 0x17
#define OPCODE_EXIT_EVENT_ERROR 0x18
#define OPCODE_STARTING 0x19
#define OPCIDE_EXITING 0x1a
#define OPCODE_DISALLOWED_PROCESS 0x1b
#define OPCODE_CREATING_INSTANCE 0x1c
#define OPCODE_NO_WHITELIST 0x1d
#define OPCODE_REPORT 0x14

//
// Tasks
//
#define TASK_PRUNE_LIBRARY 0xa
#define TASK_PRUNE_SERVICE 0xb
#define TASK_REPORT 0xd

//
// Keyword
//
#define ERROR_KEYWORD 0x1
#define REPORT_KEYWORD 0x2

//
// Event Descriptors
//
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR PROCESS_REPORT_EVENT = {0x1, 0x0, 0x14, 0x4, 0x14, 0xd, 0x8000000000000000};
#define PROCESS_REPORT_EVENT_value 0x1
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR HOST_NAME_ERROR_EVENT = {0x2, 0x0, 0x14, 0x4, 0x15, 0xa, 0x8000000000000000};
#define HOST_NAME_ERROR_EVENT_value 0x2
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR FINISHED_EVENT = {0x3, 0x0, 0x14, 0x4, 0x16, 0xa, 0x8000000000000000};
#define FINISHED_EVENT_value 0x3
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR CANNOT_GATHER_EVENT = {0x4, 0x0, 0x14, 0x4, 0x17, 0xa, 0x8000000000000000};
#define CANNOT_GATHER_EVENT_value 0x4
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EXIT_EVENT_ERROR_EVENT = {0x5, 0x0, 0x14, 0x3, 0x18, 0xa, 0x8000000000000000};
#define EXIT_EVENT_ERROR_EVENT_value 0x5
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR SERVICE_STARTING_EVENT = {0x6, 0x0, 0x14, 0x4, 0x19, 0xb, 0x8000000000000000};
#define SERVICE_STARTING_EVENT_value 0x6
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR SERVICE_EXITING_EVENT = {0x7, 0x0, 0x14, 0x4, 0x1a, 0xb, 0x8000000000000000};
#define SERVICE_EXITING_EVENT_value 0x7
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DISALLOWED_PROCESS_EVENT = {0x8, 0x0, 0x14, 0x4, 0x1b, 0xb, 0x8000000000000000};
#define DISALLOWED_PROCESS_EVENT_value 0x8
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR CREATING_INSTANCE_EVENT = {0x9, 0x0, 0x14, 0x4, 0x1c, 0xb, 0x8000000000000000};
#define CREATING_INSTANCE_EVENT_value 0x9
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR NO_WHITELIST_EVENT = {0xa, 0x0, 0x14, 0x4, 0x1d, 0xb, 0x8000000000000000};
#define NO_WHITELIST_EVENT_value 0xa
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR LIBRARY_ERROR_EVENT = {0x14, 0x0, 0x14, 0x2, 0x1e, 0xa, 0x8000000000000000};
#define LIBRARY_ERROR_EVENT_value 0x14
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR SERVICE_ERROR_EVENT = {0x15, 0x0, 0x14, 0x2, 0x1e, 0xb, 0x8000000000000000};
#define SERVICE_ERROR_EVENT_value 0x15

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Event Enablement Bits
//
EXTERN_C __declspec(selectany) DECLSPEC_CACHEALIGN ULONG Prune_LogEnableBits[1];
EXTERN_C __declspec(selectany) const ULONGLONG Prune_LogKeywords[3] = {0x8000000000000000, 0x8000000000000000, 0x8000000000000000};
EXTERN_C __declspec(selectany) const unsigned char Prune_LogLevels[3] = {4, 3, 2};

//
// Provider context
//
EXTERN_C __declspec(selectany) MCGEN_TRACE_CONTEXT PRUNE_EVENT_PROVIDER_Context = {0, (ULONG_PTR)PRUNE_EVENT_PROVIDER_Traits, 0, 0, 0, 0, 0, 0, 3, Prune_LogEnableBits, Prune_LogKeywords, Prune_LogLevels};

//
// Provider REGHANDLE
//
#define Prune_LogHandle (PRUNE_EVENT_PROVIDER_Context.RegistrationHandle)

//
// This macro is set to 0, indicating that the EventWrite[Name] macros do not
// have an Activity parameter. This is controlled by the -km and -um options.
//
#define PRUNE_EVENT_PROVIDER_EventWriteActivity 0

//
// Register with ETW using the control GUID specified in the manifest.
// Invoke this macro during module initialization (i.e. program startup,
// DLL process attach, or driver load) to initialize the provider.
// Note that if this function returns an error, the error means that
// will not work, but no action needs to be taken -- even if EventRegister
// returns an error, it is generally safe to use EventWrite and
// EventUnregister macros (they will be no-ops if EventRegister failed).
//
#ifndef EventRegisterPrune_Log
#define EventRegisterPrune_Log() McGenEventRegister(&PRUNE_EVENT_PROVIDER, McGenControlCallbackV2, &PRUNE_EVENT_PROVIDER_Context, &Prune_LogHandle)
#endif

//
// Register with ETW using a specific control GUID (i.e. a GUID other than what
// is specified in the manifest). Advanced scenarios only.
//
#ifndef EventRegisterByGuidPrune_Log
#define EventRegisterByGuidPrune_Log(Guid) McGenEventRegister(&(Guid), McGenControlCallbackV2, &PRUNE_EVENT_PROVIDER_Context, &Prune_LogHandle)
#endif

//
// Unregister with ETW and close the provider.
// Invoke this macro during module shutdown (i.e. program exit, DLL process
// detach, or driver unload) to unregister the provider.
// Note that you MUST call EventUnregister before DLL or driver unload
// (not optional): failure to unregister a provider before DLL or driver unload
// will result in crashes.
//
#ifndef EventUnregisterPrune_Log
#define EventUnregisterPrune_Log() McGenEventUnregister(&Prune_LogHandle)
#endif

//
// Enablement check macro for PROCESS_REPORT_EVENT
//
#define EventEnabledPROCESS_REPORT_EVENT() MCGEN_EVENT_BIT_SET(Prune_LogEnableBits, 0)

//
// Event write macros for PROCESS_REPORT_EVENT
//
// MC Note :: Macro for event id = 1
// This event contains complex types that require the caller to pack the data.
// Refer to the note at the top of this header for additional details.
//
#define EventWritePROCESS_REPORT_EVENT(Process, Samples, ProcessorCount, DiskCount, Processors_Len_, Processors, Disks_Len_, Disks, ComputerManufacturer, ComputerModel, ComputerProcessorNum, RamSize, ProcessorTimePercentMinimum, ProcessorTimePercentMaximum, ProcessorTimePercentAverage, WorkingSetMinimum, WorkingSetMaximum, WorkingSetAverage, PrivateBytesMinimum, PrivateBytesMaximum, PrivateBytesAverage, DiskBytesReadTotal, DiskBytesReadMinimum, DiskBytesReadMaximum, DiskBytesReadAverage, DiskBytesWrittenTotal, DiskBytesWrittenMinimum, DiskBytesWrittenMaximum, DiskBytesWrittenAverage, DiskReadOperationTotal, DiskReadOperationMinimum, DiskReadOperationMaximum, DiskReadOperationAverage, DiskWriteOperationTotal, DiskWriteOperationMinimum, DiskWriteOperationMaximum, DiskWriteOperationAverage, TcpBytesReceivedTotal, TcpBytesReceivedMinimum, TcpBytesReceivedMaximum, TcpBytesReceivedAverage, TcpBytesSentTotal, TcpBytesSentMinimum, TcpBytesSentMaximum, TcpBytesSentAverage, UdpBytesReceivedTotal, UdpBytesReceivedMinimum, UdpBytesReceivedMaximum, UdpBytesReceivedAverage, UdpBytesSentTotal, UdpBytesSentMinimum, UdpBytesSentMaximum, UdpBytesSentAverage, TcpConnectionCount, TcpConnections_Len_, TcpConnections) \
        MCGEN_EVENT_ENABLED(PROCESS_REPORT_EVENT) \
        ? McTemplateU0zqqqZRZRzzzzgggiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiqZR(&PRUNE_EVENT_PROVIDER_Context, &PROCESS_REPORT_EVENT, Process, Samples, ProcessorCount, DiskCount, Processors_Len_, Processors, Disks_Len_, Disks, ComputerManufacturer, ComputerModel, ComputerProcessorNum, RamSize, ProcessorTimePercentMinimum, ProcessorTimePercentMaximum, ProcessorTimePercentAverage, WorkingSetMinimum, WorkingSetMaximum, WorkingSetAverage, PrivateBytesMinimum, PrivateBytesMaximum, PrivateBytesAverage, DiskBytesReadTotal, DiskBytesReadMinimum, DiskBytesReadMaximum, DiskBytesReadAverage, DiskBytesWrittenTotal, DiskBytesWrittenMinimum, DiskBytesWrittenMaximum, DiskBytesWrittenAverage, DiskReadOperationTotal, DiskReadOperationMinimum, DiskReadOperationMaximum, DiskReadOperationAverage, DiskWriteOperationTotal, DiskWriteOperationMinimum, DiskWriteOperationMaximum, DiskWriteOperationAverage, TcpBytesReceivedTotal, TcpBytesReceivedMinimum, TcpBytesReceivedMaximum, TcpBytesReceivedAverage, TcpBytesSentTotal, TcpBytesSentMinimum, TcpBytesSentMaximum, TcpBytesSentAverage, UdpBytesReceivedTotal, UdpBytesReceivedMinimum, UdpBytesReceivedMaximum, UdpBytesReceivedAverage, UdpBytesSentTotal, UdpBytesSentMinimum, UdpBytesSentMaximum, UdpBytesSentAverage, TcpConnectionCount, TcpConnections_Len_, TcpConnections) : 0
#define EventWritePROCESS_REPORT_EVENT_AssumeEnabled(Process, Samples, ProcessorCount, DiskCount, Processors_Len_, Processors, Disks_Len_, Disks, ComputerManufacturer, ComputerModel, ComputerProcessorNum, RamSize, ProcessorTimePercentMinimum, ProcessorTimePercentMaximum, ProcessorTimePercentAverage, WorkingSetMinimum, WorkingSetMaximum, WorkingSetAverage, PrivateBytesMinimum, PrivateBytesMaximum, PrivateBytesAverage, DiskBytesReadTotal, DiskBytesReadMinimum, DiskBytesReadMaximum, DiskBytesReadAverage, DiskBytesWrittenTotal, DiskBytesWrittenMinimum, DiskBytesWrittenMaximum, DiskBytesWrittenAverage, DiskReadOperationTotal, DiskReadOperationMinimum, DiskReadOperationMaximum, DiskReadOperationAverage, DiskWriteOperationTotal, DiskWriteOperationMinimum, DiskWriteOperationMaximum, DiskWriteOperationAverage, TcpBytesReceivedTotal, TcpBytesReceivedMinimum, TcpBytesReceivedMaximum, TcpBytesReceivedAverage, TcpBytesSentTotal, TcpBytesSentMinimum, TcpBytesSentMaximum, TcpBytesSentAverage, UdpBytesReceivedTotal, UdpBytesReceivedMinimum, UdpBytesReceivedMaximum, UdpBytesReceivedAverage, UdpBytesSentTotal, UdpBytesSentMinimum, UdpBytesSentMaximum, UdpBytesSentAverage, TcpConnectionCount, TcpConnections_Len_, TcpConnections) \
        McTemplateU0zqqqZRZRzzzzgggiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiqZR(&PRUNE_EVENT_PROVIDER_Context, &PROCESS_REPORT_EVENT, Process, Samples, ProcessorCount, DiskCount, Processors_Len_, Processors, Disks_Len_, Disks, ComputerManufacturer, ComputerModel, ComputerProcessorNum, RamSize, ProcessorTimePercentMinimum, ProcessorTimePercentMaximum, ProcessorTimePercentAverage, WorkingSetMinimum, WorkingSetMaximum, WorkingSetAverage, PrivateBytesMinimum, PrivateBytesMaximum, PrivateBytesAverage, DiskBytesReadTotal, DiskBytesReadMinimum, DiskBytesReadMaximum, DiskBytesReadAverage, DiskBytesWrittenTotal, DiskBytesWrittenMinimum, DiskBytesWrittenMaximum, DiskBytesWrittenAverage, DiskReadOperationTotal, DiskReadOperationMinimum, DiskReadOperationMaximum, DiskReadOperationAverage, DiskWriteOperationTotal, DiskWriteOperationMinimum, DiskWriteOperationMaximum, DiskWriteOperationAverage, TcpBytesReceivedTotal, TcpBytesReceivedMinimum, TcpBytesReceivedMaximum, TcpBytesReceivedAverage, TcpBytesSentTotal, TcpBytesSentMinimum, TcpBytesSentMaximum, TcpBytesSentAverage, UdpBytesReceivedTotal, UdpBytesReceivedMinimum, UdpBytesReceivedMaximum, UdpBytesReceivedAverage, UdpBytesSentTotal, UdpBytesSentMinimum, UdpBytesSentMaximum, UdpBytesSentAverage, TcpConnectionCount, TcpConnections_Len_, TcpConnections)

//
// Enablement check macro for HOST_NAME_ERROR_EVENT
//
#define EventEnabledHOST_NAME_ERROR_EVENT() MCGEN_EVENT_BIT_SET(Prune_LogEnableBits, 0)

//
// Event write macros for HOST_NAME_ERROR_EVENT
//
#define EventWriteHOST_NAME_ERROR_EVENT(IpAddress) \
        MCGEN_EVENT_ENABLED(HOST_NAME_ERROR_EVENT) \
        ? McTemplateU0z(&PRUNE_EVENT_PROVIDER_Context, &HOST_NAME_ERROR_EVENT, IpAddress) : 0
#define EventWriteHOST_NAME_ERROR_EVENT_AssumeEnabled(IpAddress) \
        McTemplateU0z(&PRUNE_EVENT_PROVIDER_Context, &HOST_NAME_ERROR_EVENT, IpAddress)

//
// Enablement check macro for FINISHED_EVENT
//
#define EventEnabledFINISHED_EVENT() MCGEN_EVENT_BIT_SET(Prune_LogEnableBits, 0)

//
// Event write macros for FINISHED_EVENT
//
#define EventWriteFINISHED_EVENT(Process) \
        MCGEN_EVENT_ENABLED(FINISHED_EVENT) \
        ? McTemplateU0z(&PRUNE_EVENT_PROVIDER_Context, &FINISHED_EVENT, Process) : 0
#define EventWriteFINISHED_EVENT_AssumeEnabled(Process) \
        McTemplateU0z(&PRUNE_EVENT_PROVIDER_Context, &FINISHED_EVENT, Process)

//
// Enablement check macro for CANNOT_GATHER_EVENT
//
#define EventEnabledCANNOT_GATHER_EVENT() MCGEN_EVENT_BIT_SET(Prune_LogEnableBits, 0)

//
// Event write macros for CANNOT_GATHER_EVENT
//
#define EventWriteCANNOT_GATHER_EVENT(Process) \
        MCGEN_EVENT_ENABLED(CANNOT_GATHER_EVENT) \
        ? McTemplateU0z(&PRUNE_EVENT_PROVIDER_Context, &CANNOT_GATHER_EVENT, Process) : 0
#define EventWriteCANNOT_GATHER_EVENT_AssumeEnabled(Process) \
        McTemplateU0z(&PRUNE_EVENT_PROVIDER_Context, &CANNOT_GATHER_EVENT, Process)

//
// Enablement check macro for EXIT_EVENT_ERROR_EVENT
//
#define EventEnabledEXIT_EVENT_ERROR_EVENT() MCGEN_EVENT_BIT_SET(Prune_LogEnableBits, 1)

//
// Event write macros for EXIT_EVENT_ERROR_EVENT
//
#define EventWriteEXIT_EVENT_ERROR_EVENT(Process) \
        MCGEN_EVENT_ENABLED(EXIT_EVENT_ERROR_EVENT) \
        ? McTemplateU0z(&PRUNE_EVENT_PROVIDER_Context, &EXIT_EVENT_ERROR_EVENT, Process) : 0
#define EventWriteEXIT_EVENT_ERROR_EVENT_AssumeEnabled(Process) \
        McTemplateU0z(&PRUNE_EVENT_PROVIDER_Context, &EXIT_EVENT_ERROR_EVENT, Process)

//
// Enablement check macro for SERVICE_STARTING_EVENT
//
#define EventEnabledSERVICE_STARTING_EVENT() MCGEN_EVENT_BIT_SET(Prune_LogEnableBits, 0)

//
// Event write macros for SERVICE_STARTING_EVENT
//
#define EventWriteSERVICE_STARTING_EVENT() \
        MCGEN_EVENT_ENABLED(SERVICE_STARTING_EVENT) \
        ? McTemplateU0(&PRUNE_EVENT_PROVIDER_Context, &SERVICE_STARTING_EVENT) : 0
#define EventWriteSERVICE_STARTING_EVENT_AssumeEnabled() \
        McTemplateU0(&PRUNE_EVENT_PROVIDER_Context, &SERVICE_STARTING_EVENT)

//
// Enablement check macro for SERVICE_EXITING_EVENT
//
#define EventEnabledSERVICE_EXITING_EVENT() MCGEN_EVENT_BIT_SET(Prune_LogEnableBits, 0)

//
// Event write macros for SERVICE_EXITING_EVENT
//
#define EventWriteSERVICE_EXITING_EVENT() \
        MCGEN_EVENT_ENABLED(SERVICE_EXITING_EVENT) \
        ? McTemplateU0(&PRUNE_EVENT_PROVIDER_Context, &SERVICE_EXITING_EVENT) : 0
#define EventWriteSERVICE_EXITING_EVENT_AssumeEnabled() \
        McTemplateU0(&PRUNE_EVENT_PROVIDER_Context, &SERVICE_EXITING_EVENT)

//
// Enablement check macro for DISALLOWED_PROCESS_EVENT
//
#define EventEnabledDISALLOWED_PROCESS_EVENT() MCGEN_EVENT_BIT_SET(Prune_LogEnableBits, 0)

//
// Event write macros for DISALLOWED_PROCESS_EVENT
//
#define EventWriteDISALLOWED_PROCESS_EVENT() \
        MCGEN_EVENT_ENABLED(DISALLOWED_PROCESS_EVENT) \
        ? McTemplateU0(&PRUNE_EVENT_PROVIDER_Context, &DISALLOWED_PROCESS_EVENT) : 0
#define EventWriteDISALLOWED_PROCESS_EVENT_AssumeEnabled() \
        McTemplateU0(&PRUNE_EVENT_PROVIDER_Context, &DISALLOWED_PROCESS_EVENT)

//
// Enablement check macro for CREATING_INSTANCE_EVENT
//
#define EventEnabledCREATING_INSTANCE_EVENT() MCGEN_EVENT_BIT_SET(Prune_LogEnableBits, 0)

//
// Event write macros for CREATING_INSTANCE_EVENT
//
#define EventWriteCREATING_INSTANCE_EVENT(Process) \
        MCGEN_EVENT_ENABLED(CREATING_INSTANCE_EVENT) \
        ? McTemplateU0z(&PRUNE_EVENT_PROVIDER_Context, &CREATING_INSTANCE_EVENT, Process) : 0
#define EventWriteCREATING_INSTANCE_EVENT_AssumeEnabled(Process) \
        McTemplateU0z(&PRUNE_EVENT_PROVIDER_Context, &CREATING_INSTANCE_EVENT, Process)

//
// Enablement check macro for NO_WHITELIST_EVENT
//
#define EventEnabledNO_WHITELIST_EVENT() MCGEN_EVENT_BIT_SET(Prune_LogEnableBits, 0)

//
// Event write macros for NO_WHITELIST_EVENT
//
#define EventWriteNO_WHITELIST_EVENT() \
        MCGEN_EVENT_ENABLED(NO_WHITELIST_EVENT) \
        ? McTemplateU0(&PRUNE_EVENT_PROVIDER_Context, &NO_WHITELIST_EVENT) : 0
#define EventWriteNO_WHITELIST_EVENT_AssumeEnabled() \
        McTemplateU0(&PRUNE_EVENT_PROVIDER_Context, &NO_WHITELIST_EVENT)

//
// Enablement check macro for LIBRARY_ERROR_EVENT
//
#define EventEnabledLIBRARY_ERROR_EVENT() MCGEN_EVENT_BIT_SET(Prune_LogEnableBits, 2)

//
// Event write macros for LIBRARY_ERROR_EVENT
//
#define EventWriteLIBRARY_ERROR_EVENT(ErrorMessage) \
        MCGEN_EVENT_ENABLED(LIBRARY_ERROR_EVENT) \
        ? McTemplateU0z(&PRUNE_EVENT_PROVIDER_Context, &LIBRARY_ERROR_EVENT, ErrorMessage) : 0
#define EventWriteLIBRARY_ERROR_EVENT_AssumeEnabled(ErrorMessage) \
        McTemplateU0z(&PRUNE_EVENT_PROVIDER_Context, &LIBRARY_ERROR_EVENT, ErrorMessage)

//
// Enablement check macro for SERVICE_ERROR_EVENT
//
#define EventEnabledSERVICE_ERROR_EVENT() MCGEN_EVENT_BIT_SET(Prune_LogEnableBits, 2)

//
// Event write macros for SERVICE_ERROR_EVENT
//
#define EventWriteSERVICE_ERROR_EVENT(ErrorMessage) \
        MCGEN_EVENT_ENABLED(SERVICE_ERROR_EVENT) \
        ? McTemplateU0z(&PRUNE_EVENT_PROVIDER_Context, &SERVICE_ERROR_EVENT, ErrorMessage) : 0
#define EventWriteSERVICE_ERROR_EVENT_AssumeEnabled(ErrorMessage) \
        McTemplateU0z(&PRUNE_EVENT_PROVIDER_Context, &SERVICE_ERROR_EVENT, ErrorMessage)

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Template Functions
//
//
//Template from manifest : t4
//
#ifndef McTemplateU0_def
#define McTemplateU0_def
ETW_INLINE
ULONG
McTemplateU0(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor
    )
{
#define McTemplateU0_ARGCOUNT 0

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0_ARGCOUNT + 1];

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0_def

//
//Template from manifest : t2
//
#ifndef McTemplateU0z_def
#define McTemplateU0z_def
ETW_INLINE
ULONG
McTemplateU0z(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0
    )
{
#define McTemplateU0z_ARGCOUNT 1

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0z_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0z_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0z_def

//
//Template from manifest : t1
//
#ifndef McTemplateU0zqqqZRZRzzzzgggiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiqZR_def
#define McTemplateU0zqqqZRZRzzzzgggiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiqZR_def
ETW_INLINE
ULONG
McTemplateU0zqqqZRZRzzzzgggiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiqZR(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ ULONG _Arg4_Len_,
    _In_reads_(_Arg2) PCWSTR  _Arg4,
    _In_ ULONG _Arg5_Len_,
    _In_reads_(_Arg3) PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_opt_ PCWSTR  _Arg9,
    _In_ const double  _Arg10,
    _In_ const double  _Arg11,
    _In_ const double  _Arg12,
    _In_ const signed __int64  _Arg13,
    _In_ const signed __int64  _Arg14,
    _In_ const signed __int64  _Arg15,
    _In_ const signed __int64  _Arg16,
    _In_ const signed __int64  _Arg17,
    _In_ const signed __int64  _Arg18,
    _In_ const signed __int64  _Arg19,
    _In_ const signed __int64  _Arg20,
    _In_ const signed __int64  _Arg21,
    _In_ const signed __int64  _Arg22,
    _In_ const signed __int64  _Arg23,
    _In_ const signed __int64  _Arg24,
    _In_ const signed __int64  _Arg25,
    _In_ const signed __int64  _Arg26,
    _In_ const signed __int64  _Arg27,
    _In_ const signed __int64  _Arg28,
    _In_ const signed __int64  _Arg29,
    _In_ const signed __int64  _Arg30,
    _In_ const signed __int64  _Arg31,
    _In_ const signed __int64  _Arg32,
    _In_ const signed __int64  _Arg33,
    _In_ const signed __int64  _Arg34,
    _In_ const signed __int64  _Arg35,
    _In_ const signed __int64  _Arg36,
    _In_ const signed __int64  _Arg37,
    _In_ const signed __int64  _Arg38,
    _In_ const signed __int64  _Arg39,
    _In_ const signed __int64  _Arg40,
    _In_ const signed __int64  _Arg41,
    _In_ const signed __int64  _Arg42,
    _In_ const signed __int64  _Arg43,
    _In_ const signed __int64  _Arg44,
    _In_ const signed __int64  _Arg45,
    _In_ const signed __int64  _Arg46,
    _In_ const signed __int64  _Arg47,
    _In_ const signed __int64  _Arg48,
    _In_ const signed __int64  _Arg49,
    _In_ const signed __int64  _Arg50,
    _In_ const unsigned int  _Arg51,
    _In_ ULONG _Arg52_Len_,
    _In_reads_(_Arg51) PCWSTR  _Arg52
    )
{
#define McTemplateU0zqqqZRZRzzzzgggiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiqZR_ARGCOUNT 53

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0zqqqZRZRzzzzgggiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiqZR_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],_Arg4, (ULONG)(sizeof(WCHAR)*_Arg4_Len_)); // Blob containing _Arg2 concatenated nul-terminated strings

    EventDataDescCreate(&EventData[6],_Arg5, (ULONG)(sizeof(WCHAR)*_Arg5_Len_)); // Blob containing _Arg3 concatenated nul-terminated strings

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],
                        (_Arg9 != NULL) ? _Arg9 : L"NULL",
                        (_Arg9 != NULL) ? (ULONG)((wcslen(_Arg9) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[11],&_Arg10, sizeof(const double)  );

    EventDataDescCreate(&EventData[12],&_Arg11, sizeof(const double)  );

    EventDataDescCreate(&EventData[13],&_Arg12, sizeof(const double)  );

    EventDataDescCreate(&EventData[14],&_Arg13, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[15],&_Arg14, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[16],&_Arg15, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[17],&_Arg16, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[18],&_Arg17, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[19],&_Arg18, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[20],&_Arg19, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[21],&_Arg20, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[22],&_Arg21, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[23],&_Arg22, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[24],&_Arg23, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[25],&_Arg24, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[26],&_Arg25, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[27],&_Arg26, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[28],&_Arg27, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[29],&_Arg28, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[30],&_Arg29, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[31],&_Arg30, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[32],&_Arg31, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[33],&_Arg32, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[34],&_Arg33, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[35],&_Arg34, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[36],&_Arg35, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[37],&_Arg36, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[38],&_Arg37, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[39],&_Arg38, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[40],&_Arg39, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[41],&_Arg40, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[42],&_Arg41, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[43],&_Arg42, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[44],&_Arg43, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[45],&_Arg44, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[46],&_Arg45, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[47],&_Arg46, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[48],&_Arg47, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[49],&_Arg48, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[50],&_Arg49, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[51],&_Arg50, sizeof(const signed __int64)  );

    EventDataDescCreate(&EventData[52],&_Arg51, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[53],_Arg52, (ULONG)(sizeof(WCHAR)*_Arg52_Len_)); // Blob containing _Arg51 concatenated nul-terminated strings

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0zqqqZRZRzzzzgggiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiqZR_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0zqqqZRZRzzzzgggiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiqZR_def

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

#if defined(__cplusplus)
};
#endif

#define MSG_Opcode_Error                     0x3000001EL
#define MSG_Task_Library_Host                0x300A0015L
#define MSG_Task_Library_Finished            0x300A0016L
#define MSG_Task_Library_CannotGather        0x300A0017L
#define MSG_Task_Library_ExitEvent           0x300A0018L
#define MSG_Task_Service_Starting            0x300B0019L
#define MSG_Task_Service_Exiting             0x300B001AL
#define MSG_Task_Service_Disallowed          0x300B001BL
#define MSG_Task_Service_CreatingInstance    0x300B001CL
#define MSG_Task_Service_NoWhitelist         0x300B001DL
#define MSG_Task_Reporting_Report            0x300D0014L
#define MSG_Task_Library                     0x7000000AL
#define MSG_Task_Service                     0x7000000BL
#define MSG_Task_Reporting                   0x7000000DL
#define MSG_Provider_Name                    0x90000001L
#define MSG_Event_ProcessReport              0xB0000001L
#define MSG_Event_HostNameError              0xB0000002L
#define MSG_Event_Finished                   0xB0000003L
#define MSG_Event_CannotGather               0xB0000004L
#define MSG_Event_ExitEvent                  0xB0000005L
#define MSG_Event_ServiceStarting            0xB0000006L
#define MSG_Event_ServiceExiting             0xB0000007L
#define MSG_Event_DisallowedProcess          0xB0000008L
#define MSG_Event_CreatingInstance           0xB0000009L
#define MSG_Event_NoWhitelist                0xB000000AL
#define MSG_Event_LibraryError               0xB0000014L
#define MSG_Event_ServiceError               0xB0000015L
